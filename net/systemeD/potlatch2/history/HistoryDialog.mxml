<?xml version="1.0" encoding="utf-8"?>
<mx:TitleWindow
        xmlns:mx="http://www.adobe.com/2006/mxml"
        xmlns:help="net.systemeD.potlatch2.help.*"
        layout="vertical" showCloseButton="true"
        horizontalAlign="center" title="History"
        width="600" height="400"
        verticalGap="0">

  <mx:VBox width="100%" height="100%">
    <mx:HBox width="100%">
      <mx:Text text="History for {entity.getType()} {entity.id}" selectable="false" width="50%" />
      <mx:Text text="Loading data..." visible="{ entityStates == null }" selectable="false" />
    </mx:HBox>
    <mx:HBox width="100%" height="100%">
      <mx:DataGrid dataProvider="{entityStates}" width="100%" height="100%" enabled="{ entityStates != null }">
        <mx:columns>
          <mx:DataGridColumn editable="false" dataField="version" headerText="version" width="50" textAlign="center"/>
          <mx:DataGridColumn editable="false" dataField="timestamp" headerText="timestamp"/>
          <mx:DataGridColumn editable="false" dataField="user" headerText="username" />
          <mx:DataGridColumn editable="false">
            <mx:itemRenderer>
              <mx:Component>
                <mx:HBox horizontalAlign="center" verticalAlign="middle">
                  <mx:Button label="Contact User"
                    click="parentDocument.message(data)"/>
                </mx:HBox>
              </mx:Component>
            </mx:itemRenderer>
          </mx:DataGridColumn>
        </mx:columns>
      </mx:DataGrid>
    </mx:HBox>
  </mx:VBox>


  <mx:ControlBar>
    <mx:Button label="Revert" enabled="false" styleName="titleWindowButton" />
    <mx:Spacer width="100%"/>
    <mx:Button label="More Details..." enabled="{entity.id >= 0}" click="openEntityPage()" styleName="titleWindowButton" />
    <mx:Button label="Cancel" click="PopUpManager.removePopUp(this);" styleName="titleWindowButton" />
  </mx:ControlBar>

  <mx:Script><![CDATA[

    import mx.managers.PopUpManager;
    import mx.core.Application;
    import mx.events.CloseEvent;
    import flash.events.Event;
    import com.adobe.utils.ArrayUtil;

    import net.systemeD.halcyon.connection.*

    [Bindable]
    private var entity:Entity;

    [Bindable]
    private var entityStates:Array;

    // store intermediate states for ways
    private var wayStates:Array; // an array of ways
    private var wayNodeStates:Array; // an array of arrays of nodes
    private var pendingNodeFetches:uint;

    public function init(e:Entity):void {
        if (e == null) {return;}

        PopUpManager.addPopUp(this, Application(Application.application), true);
        PopUpManager.centerPopUp(this);
        this.addEventListener(CloseEvent.CLOSE, historyDialog_close);

        entity = e;
        fetchHistory();
    }

    private function historyDialog_close(evt:CloseEvent):void {
        PopUpManager.removePopUp(this);
    }

    /** Open up a new browser page showing OSM's view of the current entity. */
    private function openEntityPage():void {
        if (entity != null && entity.id >= 0) {
            // This is slightly hard-coded, but not drastically. The ../s could be changed for string manipulation of the apiBase
            var urlBase:String = Connection.getConnectionInstance().apiBase + '../../browse/';
            navigateToURL(new URLRequest(urlBase+entity.getType()+'/'+entity.id), "potlatch_browse");
        }
    }

    private function fetchHistory():void {
        if (entity is Node) {
            Connection.getConnection().fetchHistory(entity, processNode);
        } else if (entity is Way) {
            Connection.getConnection().fetchHistory(entity, processWay);
        } else {
            // not implemented
        }
    }

    private function processNode(results:Array):void {
        // Simply copy the nodes into the states array
        // todo sorting or somesuch
        entityStates = results.reverse();
    }

    private function processWay(results:Array):void {
        // This is much more complicated that nodes.
        // In potlatch(2) we show the user the number of different states, bearing in mind
        // node movements (and tag changes?).

        wayStates = results;

        wayNodeStates = [];
        addEventListener("pendingNodesAllFetched", processWayStates);

        var nodes:Object = {};
        var count:uint = 0;

        for each(var oldWay:Way in results) {
            trace(oldWay);
            for (var i:uint = 0; i< oldWay.length; i++) {
                var node:Node = oldWay.getNode(i);
                if(!nodes[node.id]) {
                    nodes[node.id] = node;
                    count++;
                }
            }
        }

        pendingNodeFetches = count;

        for each (var n:Node in nodes) {
            trace("fetching node " + n.id);
            Connection.getConnection().fetchHistory(n, pendingNode);
        }
    }

    private function pendingNode(results:Array):void {
        wayNodeStates.push(results)
        pendingNodeFetches--;
        trace("fetched node "+results[0].id+" , "+pendingNodeFetches+" more to go");
        if (pendingNodeFetches == 0) {
            dispatchEvent(new Event("pendingNodesAllFetched"));
            trace("done");
        }
    }

    private function processWayStates(e:Event):void {
        // we now have all the nodes
        // for each way

        var revdates:Array = [];
        var revusers:Object = {};

        for each (var way:Way in wayStates) {
            revdates.push(way.timestamp);
            revusers[way.timestamp] = way.user;
        }

        for each (var nodeStates:Array in wayNodeStates) {
            for each (var node:Node in nodeStates) {
                revdates.push(node.timestamp);
                revusers[node.timestamp] = node.user;
            }
        }

        // sort the dates and remove duplicates and those before the first version of the way

        revdates = revdates.sort();
        revdates = ArrayUtil.createUniqueCopy(revdates); // (corelib) de-duplicates
        revdates = revdates.filter(function(e:*, i:int, arr:Array):Boolean { return e >= wayStates[0].timestamp});

        var version:int = 1;
        var subversion:int = 0;
        var es:Array = []; // entityStates

        for each (var revdate:String in revdates) {
          var entitystate:Object = {};


          var w:Way = getEntityAtDate(wayStates, revdate) as Way;
          if (w.version == version) {
              subversion++;
          } else {
              version = w.version;
              subversion = 1;
          }

          //for (i = 0, i < w.length; i++) {
          //    var generalNode:Node = w.getNode(i);
          //    var specificNode:Node = getEntityAtDate(wayNodeStates[generalNode.id], revdate);
          //    where was I going with this? Oh, yes, it'll be needed for building the object to revert to.
          //}

          entitystate.version = String(version) + "." + String(subversion);
          entitystate.timestamp = revdate;
          entitystate.user = revusers[revdate];
          es.push(entitystate)
        }

        entityStates = es.reverse();
    }

    // given a list of entities sorted with oldest first, find the last version before that date.
    private function getEntityAtDate(list:Array, date:String):Entity {
        trace("find for date : "+date);
        for(var i:int = list.length-1; i >= 0; i--) {
            var entity:Entity = list[i];
            trace (entity.timestamp + " : " + date);
            if (entity.timestamp <= date) {
                trace("returning version " + entity.version);
                return entity;
            }
        }
        trace("ERROR");
        return null;
    }

    public function message(entity:Entity):void {
        if (entity.user != null) {
            var urlBase:String = Connection.getConnectionInstance().apiBase + '../../message/new/';
            navigateToURL(new URLRequest(urlBase+entity.user), "potlatch_message");
        }
    }
    ]]>
  </mx:Script>


</mx:TitleWindow>


